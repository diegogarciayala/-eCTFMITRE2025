"""
Author: TrustLab Team
Date: 2025

This source file is part of a secure satellite TV transmission system for MITRE's 2025
Embedded System CTF (eCTF). This code implements subscription generation for the
satellite TV system.

Copyright: Copyright (c) 2025
"""

import argparse
import json
import base64
import struct
from pathlib import Path
import time

from loguru import logger
from .utils import aes_cmac, bytes_to_hex


def gen_subscription(
        secrets: bytes, device_id: int, start: int, end: int, channel: int
) -> bytes:
    """Generate the contents of a subscription.

    The output of this will be passed to the Decoder using ectf25.tv.subscribe

    :param secrets: Contents of the secrets file generated by ectf25_design.gen_secrets
    :param device_id: Device ID of the Decoder
    :param start: First timestamp the subscription is valid for
    :param end: Last timestamp the subscription is valid for
    :param channel: Channel to enable
    """
    # Load the secrets file
    secrets_json = json.loads(secrets)

    # Decode the master key and encoder ID from base64
    master_key = base64.b64decode(secrets_json["master_key"])
    encoder_id = base64.b64decode(secrets_json["encoder_id"])
    signature_key = base64.b64decode(secrets_json["signature_key"])

    # Verify that the requested channel is valid
    if channel != 0 and channel not in secrets_json["channels"]:
        raise ValueError(f"Channel {channel} is not valid in this deployment")

    # Create the subscription data structure
    subscription_data = struct.pack("<IQQI", device_id, start, end, channel)

    # Add encoder ID to the subscription for validation
    # Ensure all inputs are bytes, not bytearray
    if isinstance(master_key, bytearray):
        master_key = bytes(master_key)
    if isinstance(signature_key, bytearray):
        signature_key = bytes(signature_key)
    if isinstance(encoder_id, bytearray):
        encoder_id = bytes(encoder_id)
    if isinstance(subscription_data, bytearray):
        subscription_data = bytes(subscription_data)

    subscription_with_id = encoder_id + subscription_data

    # Create a secure signature of the subscription using AES-CMAC
    signature = aes_cmac(signature_key, subscription_with_id)

    # Final subscription includes: encoder_id + subscription_data + signature
    # Ensure signature is also in bytes format
    if isinstance(signature, bytearray):
        signature = bytes(signature)

    complete_subscription = subscription_with_id + signature

    logger.debug(f"Subscription data: device_id={device_id}, start={start}, end={end}, channel={channel}")
    logger.debug(f"Encoder ID: {bytes_to_hex(encoder_id)}")
    logger.debug(f"Signature: {bytes_to_hex(signature)}")

    return complete_subscription


def parse_args():
    """Define and parse the command line arguments

    NOTE: Your design must not change this function
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="Force creation of subscription file, overwriting existing file",
    )
    parser.add_argument(
        "secrets_file",
        type=argparse.FileType("rb"),
        help="Path to the secrets file created by ectf25_design.gen_secrets",
    )
    parser.add_argument("subscription_file", type=Path, help="Subscription output")
    parser.add_argument(
        "device_id", type=lambda x: int(x, 0), help="Device ID of the update recipient."
    )
    parser.add_argument(
        "start", type=lambda x: int(x, 0), help="Subscription start timestamp"
    )
    parser.add_argument("end", type=int, help="Subscription end timestamp")
    parser.add_argument("channel", type=int, help="Channel to subscribe to")
    return parser.parse_args()


def main():
    """Main function of gen_subscription"""
    # Parse the command line arguments
    args = parse_args()

    subscription = gen_subscription(
        args.secrets_file.read(), args.device_id, args.start, args.end, args.channel
    )

    # Print the generated subscription for your own debugging
    # Attackers will NOT have access to the output of this (although they may have
    # subscriptions in certain scenarios), but feel free to remove
    #
    # NOTE: Printing sensitive data is generally not good security practice
    logger.debug(f"Generated subscription: {subscription}")

    # Open the file, erroring if the file exists unless the --force arg is provided
    with open(args.subscription_file, "wb" if args.force else "xb") as f:
        f.write(subscription)

    # For your own debugging. Feel free to remove
    logger.success(f"Wrote subscription to {str(args.subscription_file.absolute())}")


if __name__ == "__main__":
    main()
